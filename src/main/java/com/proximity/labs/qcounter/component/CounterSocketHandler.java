package com.proximity.labs.qcounter.component;

import com.proximity.labs.qcounter.data.dto.response.ApiResponse;
import com.proximity.labs.qcounter.data.models.queue.Queue;
import com.proximity.labs.qcounter.data.models.user.User;
import com.proximity.labs.qcounter.service.CounterSocketService;
import com.proximity.labs.qcounter.service.QueueService;
import com.proximity.labs.qcounter.utils.CounterSocketAtrr;
import org.apache.log4j.Logger;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Component;
import org.springframework.web.socket.CloseStatus;
import org.springframework.web.socket.TextMessage;
import org.springframework.web.socket.WebSocketSession;
import org.springframework.web.socket.handler.TextWebSocketHandler;

import java.io.IOException;
import java.util.HashMap;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;

@Component
public class CounterSocketHandler extends TextWebSocketHandler {


    /**
     * Store all sessions from "join" target path in a hashmap. The key is queue id.
     */
    private final HashMap<String, Set<WebSocketSession>> joinQueueSessions;

    /**
     * Store all sessions from "home" target path in a hashmap. The key is queue id.
     */
    private final HashMap<String, Set<WebSocketSession>> homeSessions;

    /**
     * Store all sessions from "control" target path in a hashmap. The key is queue id.
     */
    private final HashMap<String, Set<WebSocketSession>> controlSessions;

    /**
     * Store all sessions from "queues" target path in a hashmap. The key is queue id.
     */
    private final HashMap<String, Set<WebSocketSession>> queuesSessions;

    /**
     * Store all sessions from "my_queues" target path in a hashmap. The key is queue id.
     */
    private final HashMap<String, Set<WebSocketSession>> myQueuesSessions;


    @SuppressWarnings("unused")
    private static final Logger logger = Logger.getLogger(CounterSocketHandler.class);

    private final QueueService queueService;
    private final CounterSocketService counterSocketService;

    public CounterSocketHandler(QueueService queueService, CounterSocketService counterSocketService) {
        this.queueService = queueService;
        this.counterSocketService = counterSocketService;
        this.joinQueueSessions = counterSocketService.getJoinQueueSessions();
        this.homeSessions = counterSocketService.getHomeSessions();
        this.controlSessions = counterSocketService.getControlSessions();
        this.queuesSessions = counterSocketService.getQueuesSessions();
        this.myQueuesSessions = counterSocketService.getMyQueuesSessions();
    }

    /**
     * {@inheritDoc}
     * Handle the incoming message based on target path.
     *
     * @param session
     * @param message
     */
    @Override
    public void handleTextMessage(WebSocketSession session, TextMessage message) {
        String queueId = session.getAttributes().getOrDefault(CounterSocketAtrr.QUEUE_ID.label, "").toString();
        CounterSocketAtrr targetPath = (CounterSocketAtrr) session.getAttributes().getOrDefault(CounterSocketAtrr.TARGET_PATH.label, "");
        Optional<Queue> queue = queueService.findFirstByClientGeneratedId(queueId);
        if (targetPath == CounterSocketAtrr.CONTROL) {
            queue.ifPresent(q -> {
                if (counterSocketService.verifyOwnership(session.getPrincipal(), q))
                    counterSocketService.performChanges(q, message, session);
            });
        }

        if (queue.isEmpty())
            counterSocketService.sendErrorAndCloseConnection(new ApiResponse(false, String.format("Queue with id %s not found", queueId)), session);
    }

    /**
     * {@inheritDoc}
     * Checks for missing or incorrect params based on target path.
     * if there's any missing or incorrect params. send the error response
     * and terminate the connection. if all checks passed. then send initial message
     * generated by {@initialBroadcastMessage}
     *
     * @param session
     */
    @Override
    public void afterConnectionEstablished(WebSocketSession session) {
        String queueId = session.getAttributes().getOrDefault(CounterSocketAtrr.QUEUE_ID.label, "").toString();
        CounterSocketAtrr targetPath = (CounterSocketAtrr) session.getAttributes().getOrDefault(CounterSocketAtrr.TARGET_PATH.label, "");
        Optional<Queue> queue = queueService.findFirstByClientGeneratedId(queueId);

        switch (targetPath) {
            case JOIN, CONTROL -> {
                if (queueId.isEmpty())
                    counterSocketService.sendErrorAndCloseConnection(new ApiResponse(false, "Missing queue id"), session);
                if (queue.isEmpty()) {
                    counterSocketService.sendErrorAndCloseConnection(new ApiResponse(false, String.format("Queue with id %s not found", queueId)), session);
                }
            }
        }

        counterSocketService.initialBroadcastMessage(session, queue.orElse(null), targetPath).ifPresent(message -> {
            try {
                session.sendMessage(new TextMessage(message));
            } catch (IOException e) {
                e.printStackTrace();
            }
        });
    }


    /**
     * {@inheritDoc}
     * <p>
     * Clear all stored session on all groups. Some session subscribed to
     * multiple queues. This also clears all that.
     *
     * @param session
     * @param status
     */
    @Override
    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) {
        String queueId = session.getAttributes().getOrDefault(CounterSocketAtrr.QUEUE_ID.label, "").toString();
        if (joinQueueSessions.containsKey(queueId))
            joinQueueSessions.get(queueId).remove(session);
        if (homeSessions.containsKey(queueId))
            homeSessions.get(queueId).remove(session);
        if (controlSessions.containsKey(queueId))
            controlSessions.get(queueId).remove(session);
        User user = (User) ((Authentication) Objects.requireNonNull(session.getPrincipal())).getPrincipal();
        user.getMyQueues().forEach(queue -> {
            if (homeSessions.containsKey(queue.getClientGeneratedId()))
                homeSessions.get(queue.getClientGeneratedId()).remove(session);
        });
        user.getQueues().forEach(inQueue -> {
            if (queuesSessions.containsKey(inQueue.getQueue().getClientGeneratedId()))
                queuesSessions.get(inQueue.getQueue().getClientGeneratedId()).remove(session);
        });
        user.getMyQueues().forEach(queue -> {
            if (myQueuesSessions.containsKey(queue.getClientGeneratedId()))
                myQueuesSessions.get(queue.getClientGeneratedId()).remove(session);
        });
    }
}


